{
  "Impact": "There is a race condition between the bind()\nand the connect() where I can steal the port to the ssh process. By having access to the bound port in the ssh process, you can get\naccess to the other side, simply by connecting, closing the\nconnection, and then binding the port yourself and waiting for the\nagent to connect to you. After doing this, you have access to the\noriginal authentication tunnel, and can submit queries to it yourself. This obviously allows for a man in the middle attack. The attack allows a local user to use another local\nuser's credentials. However, the attack can only be executed by\nanother local user, and it generally does not allow root access. The attack can only be performed when the victim user is on-line, and\nthe victim will see that something went wrong.", 
  "CVSS_SecurityRequirementsIR": "", 
  "CVSS_EnvironmentalVector": "", 
  "Title": "ssh", 
  "DateFirstPublished": "", 
  "CVSS_AccessVector": "", 
  "CAM_ScoreCurrentWidelyKnown": 5.28, 
  "IDNumber": "6518", 
  "SystemsAffectedPreamble": "", 
  "CVSS_SecurityRequirementsCR": "", 
  "CVSS_Authenication": "", 
  "CVSS_BaseScore": "", 
  "CAM_EaseOfExploitation": "10", 
  "IPProtocol": "", 
  "CERTAdvisory": "", 
  "CVSS_CollateralDamagePotential": "", 
  "Revision": "1", 
  "CVEIDs": "", 
  "VRDA_D1_DirectReport": "", 
  "CAM_WidelyKnown": "16", 
  "CAM_Population": "4", 
  "Description": "attack on ssh's authentication forwarding\nmechanism that allows another user on the same machine to steal a\nconnection to your authentication agent.  This allows said user to\nconnect to servers as yourself.\n\nNote that this is an active attack.  It relies on a race condition,\nand may only be performed while a ssh process is being started up and\nis constructing a tunnel to the authentication agent.  Nevertheless,\nit is a serious hole.\n\nIf you are connecting to or from a machine that may have other users,\nyou should kill any `ssh-agent' processes you may have running, and\nput `ForwardAgent no' in your .ssh/config file until this hole is\nfixed.", 
  "CVSS_AccessComplexity": "", 
  "CVSS_SecurityRequirementsAR": "", 
  "Resolution": "", 
  "Author": "This document was written by CN=Georgia T Killcrece/O=CERT.", 
  "CAM_Exploitation": "20", 
  "DateLastUpdated": "1998-05-21T11:44:21-04:00", 
  "CVSS_IntegrityImpact": "", 
  "VRDA_D1_Population": "", 
  "CVSS_TemporalVector": "", 
  "CVSS_ReportConfidence": "", 
  "CVSS_ConfidentialityImpact": "", 
  "CVSS_BaseVector": "", 
  "VulnerabilityCount": 1, 
  "CVSS_Exploitability": "", 
  "ThanksAndCredit": "", 
  "US-CERTTechnicalAlert": "", 
  "CAM_ScoreCurrentWidelyKnownExploited": 5.28, 
  "CVSS_TemporalScore": "", 
  "VRDA_D1_Impact": "", 
  "CVSS_TargetDistribution": "", 
  "CAM_InternetInfrastructure": "4", 
  "CVSS_RemediationLevel": "", 
  "Workarounds": "In the case where you're using a Un*x-domain socket for the agent,\nthis is really easy to fix, just by ripping out the use of the local\nIP port, and simply allowing multiple connections to the socket. In the case where the agent is using an inherited file descriptor,\nit's a bit more complicated. One option is to create temporary named\nUn*x-domain sockets and bind them; however, if you do this, it's not\nclear that it's worth using the inherited descriptor at all. An alternative solution (pointed out by Marc Horowitz), is to leave\nthe original listening socket around. This has the disadvantage that\nit still allows someone to steal the port to the incoming challenges. Although how this would be a hole isn't immediately obvious to me, it\nseems inherently wrong to allow it.", 
  "ID": "VU#6518", 
  "CVSS_AvailabilityImpact": "", 
  "CAM_ScoreCurrent": 4.8, 
  "Overview": "", 
  "CAM_Impact": "16", 
  "DatePublic": "", 
  "DateCreated": "1999-01-05T17:35:10-05:00", 
  "References": "posted to bugtraq, Fri, 11 Oct 1996", 
  "Keywords": [
    "ssh", 
    "race condition", 
    "timing window", 
    "authentication forwarding", 
    "tunneling"
  ], 
  "CVSS_EnvironmentalScore": "", 
  "CAM_AttackerAccessRequired": "10"
}