{
  "Impact": "", 
  "CVSS_SecurityRequirementsIR": "", 
  "CVSS_EnvironmentalVector": "", 
  "Title": "asnfBSD_socket_deadlock", 
  "DateFirstPublished": "", 
  "CVSS_AccessVector": "", 
  "CAM_ScoreCurrentWidelyKnown": 11.1375, 
  "IDNumber": "8430", 
  "SystemsAffectedPreamble": "", 
  "CVSS_SecurityRequirementsCR": "", 
  "CVSS_Authenication": "", 
  "CVSS_BaseScore": "", 
  "CAM_EaseOfExploitation": "15", 
  "IPProtocol": "", 
  "CERTAdvisory": "", 
  "CVSS_CollateralDamagePotential": "", 
  "Revision": "1", 
  "CVEIDs": "", 
  "VRDA_D1_DirectReport": "", 
  "CAM_WidelyKnown": "1", 
  "CAM_Population": "20", 
  "Description": "There is a bug in the kernel which allows every user to create a\ndead lock by trying to read \"-1\" bytes from a socket that has some\ndata in its receive buffer. When this happens the O/S simply hangs\nforever. Below is a program that exploits this bug.\n\nThe reason for the bug is because \"struct uio\" has a field \"uio.resid\"\nwhich is an \"int\", while the user's argument is \"u_int\". Later in the\ncode, in soreceive() if the call doesn't block due to no data in the\nsocket, the actual receive loop is skipped (uio.resid IS NOT > 0) -\nline ~737 in uipc_socket.c. But the test for termination condition is\nfalse also - line ~853 in uipc_socket.c. So it executes \"goto restart\"\nand starts the loop over.", 
  "CVSS_AccessComplexity": "", 
  "CVSS_SecurityRequirementsAR": "", 
  "Resolution": "", 
  "Author": "This document was written by CN=Georgia T Killcrece/O=CERT.", 
  "CAM_Exploitation": "10", 
  "DateLastUpdated": "1999-02-15T10:13:38-05:00", 
  "CVSS_IntegrityImpact": "", 
  "VRDA_D1_Population": "", 
  "CVSS_TemporalVector": "", 
  "CVSS_ReportConfidence": "", 
  "CVSS_ConfidentialityImpact": "", 
  "CVSS_BaseVector": "", 
  "VulnerabilityCount": 1, 
  "CVSS_Exploitability": "", 
  "ThanksAndCredit": "", 
  "US-CERTTechnicalAlert": "", 
  "CAM_ScoreCurrentWidelyKnownExploited": 14.5125, 
  "CVSS_TemporalScore": "", 
  "VRDA_D1_Impact": "", 
  "CVSS_TargetDistribution": "", 
  "CAM_InternetInfrastructure": "3", 
  "CVSS_RemediationLevel": "", 
  "Workarounds": "1. Like FreeBSD, add these tests. On the other hand, this seems to\nbreak the rules: if the user requests more than MAX_INT it will receive\nan error. 2. Fix \"uio\" structure to have \"uio.resid\" and \"u_int\" instead. I'm\nnot sure what are the other implications of this. In addition, the\nuser might, again, not be satisfied as there may be an overflow\ncondition (e.g. the user requests, via \"readv\" more than 2^32 bytes,\nbut actually gets that amount modulu 2^32).", 
  "ID": "VU#8430", 
  "CVSS_AvailabilityImpact": "", 
  "CAM_ScoreCurrent": 4.725, 
  "Overview": "", 
  "CAM_Impact": "6", 
  "DatePublic": "", 
  "DateCreated": "1998-05-21T11:55:52-04:00", 
  "References": "", 
  "Keywords": [
    "socket", 
    "negative buffer size", 
    "deadlock"
  ], 
  "CVSS_EnvironmentalScore": "", 
  "CAM_AttackerAccessRequired": "10"
}